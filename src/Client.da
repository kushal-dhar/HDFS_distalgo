"""
The client interface which acts as a mediator between namenode and users for processing requests

"""
import Config
import time
import Utils

"""
Client HeartBeat process to notify the NameNode
that the client is awake and running
"""
class ClientNodeHeartbeat(process):
    def setup(clientnode, namenode, interval=Config.CLIENT_HEARTBEAT_INTERVAL):
        pass

    def run():
        output('started heartbeat process for client: ', clientnode)
        while True:
            # output('sending heartbeat', self)
            send(('heartbeat_client', clientnode), to=namenode)
            time.sleep(interval)


    def receive(msg=('kill')):
        output('received kill')
        exit(0)


"""
Client process to accept multiple read and write requests
"""
'''
class UserReq_Handle(process):

    def setup(filename,mode,messageId,token,user):
        self.filename = filename #name of filename to be edited
        self.mode = mode #Opening the file in read or write 'mode'
        self.messageId = messageId #Unique number identifying every message
        self.token = token #Token for differenciating operations to the same file
        self.user = user #User process performing the operation to the file system


    def run():
        output('awaiting to aquire lease ')
        output("awaiting for args: ",filename, mode, messageId)
        await(some(received(('openFile', _filename, _mode, _messageId, _))))
        result = setof(r, received(('openFile', _filename, _mode, _messageId, r)))
        output("result: ", result)
        for r in result:
            pass
        output('client: received result of open from namenode for file: ', filename, ' result= ', r)
        send(('openFile', mode, token, filename, r), to=user)
        exit(0)

    def receive(msg=('openFile', filename, mode, messageId, result)):
        output("result: ", filename, mode, messageId, result)
        exit(0)
'''


"""
Client process in HDFS cluster.
Users interact with HDFS by sending messages to Client
"""


class Client(process):

    def setup(namenodes):
        # msgId is used with all messages sent to namenode to differentiate between different user requests
        # For example, a user can send 2 request for creating the same file. msgId differentiates between these 2 requests
        self.msgId = 0
        # Namenode with which the client interacts
        self.namenodes = namenodes


    def run():
        output('client running: ', self)
        # Start heartbeat process for this client
        heartbeatProcess = new(ClientNodeHeartbeat, num=1, at=Config.CLIENT_LOCATION)
        for hbp in heartbeatProcess:
            setup(hbp, args=(self, namenodes))
        start(heartbeatProcess)

        # Wait for terminate message
        await(received(('kill')))


    """
	Unique messageId generator
    """
    def getNewMessageId():
        messageId = self.msgId
        self.msgId += 1
        return messageId

    """
        Handl API calls for creating a file. Returns true if successful, else false
    """
    def receive(msg=('createFile', token, filename), from_=user):
        output('client: received createFile file={0} from user={1}'.format(filename, user))
        messageId = getNewMessageId()
        output('client: sending createFile msg with id={0} to namenode'.format(messageId))
        send(('createFile', self, filename, messageId), to=namenodes)

        await(some(received(('createFile', _filename, _messageId, _))))
        result = setof(r, received(('createFile', _filename, _messageId, r)))
        output('client: createFile: result={0} for filename={1}'.format(result, filename))
        r = Utils.getOneFromSet(result)
        output('client: received result from namenode ', r, ' for filename ', filename)
        send(('createFile', token, filename, r), to=user)

    """
       Handles request to list files in our filesystem, True if successful, else return false
    """
    def receive(msg=('listFiles', token), from_=user):
        output('client: received listFiles from user:', user)
        messageId = getNewMessageId()
        output('sending listFiles request to namenode with msgId: ', messageId)
        send(('listFiles', self, messageId), to=namenodes)

        await(some(received(('listFiles', _messageId, _))))
        #output('got reply!!')
        result = setof(r, received(('listFiles', _messageId, r)))
        output('result: ', result)
        r = Utils.getOneFromSet(result)
        output('received listFiles result from namenode ', r)
        send(('listFiles', token, r), to=user)

   """
	Handles request to aquire lease for the user before it attempts to read or write,Returns true if successfull,else returns false
   """
    def receive(msg=('openFile', mode, token, filename), from_=user):
        output('client: received openFile: filename=', filename, ', token=', token)
        messageId = getNewMessageId()
        output('sending open request to namenode for: ', filename, ' with msgId: ', messageId)
        send(('openFile', mode, self, filename, messageId), to=namenodes)
        # reqs = new(UserReq_Handle, num=1)
        # for req in reqs:
        #     setup(req, args=(filename, mode, messageId, token, user))
        # start(reqs)
        await(some(received(('openFile', _filename, _mode, _messageId, _))))
        #Reply back to client with the result
        result = setof(r, received(('openFile', _filename, _mode, _messageId ,r)))
        r = Utils.getOneFromSet(result)
        output('client: received result of open from namenode for file: ', filename, ' result= ', r)
        send(('openFile', mode, token, filename, r), to=user)

    """
	Handles request to forgo the lease once the user has done writing
    """
    def receive(msg=('closeFile', mode, token, filename), from_=user):
        output('client: received closeFile: filename=', filename, ', token=', token)
        messageId = getNewMessageId()
        output('sending close request to namenode for: ', filename, ' with msgId: ', messageId)
        send(('closeFile', mode, self, filename, messageId), to=namenodes)
        await(some(received(('closeFile', _filename, _mode, _messageId, True))))
        result = setof(r, received(('closeFile', _filename, _mode, _messageId, r)))
        for r in result:
            pass
        output('client: received result of close from namenode for file: ', filename, ' result= ', r)
        send(('closeFile', mode, token, filename, r), to=user)

    """
	When an application reads a file, the HDFS client first asks 
	the  NameNode  for  the  list  of  DataNodes  that  host  replicas  of 
	the blocks of the file. It then contacts a DataNode directly and 
	requests the transfer of the desired block
    """
    def receive(msg=('readFile', token, filename, mblockNumber, nbytes), from_=user):
        output('client: received readFile: filename={0}, blockNumber={1}, nbytes={2}, token={3}'.format(filename, mblockNumber, nbytes, token))
        # TODO: get file size before reading, or ask for number of blocks from namenode
        bytes_read = 0
        blockNumber = 0
        data = b''
        messageId = getNewMessageId()
        send(('numBlocksInFile', filename, messageId), to=namenodes)
        await(some(received(('numBlocksInFile', _filename, _messageId, _))))
        result = setof(r, received( ('numBlocksInFile', _filename, _messageId, r) ))
        total_blocks = Utils.getOneFromSet(result)
        output("client: number of blocks in file={0} = {1}".format(filename, total_blocks))

        while bytes_read < nbytes and blockNumber < total_blocks:
            messageId = getNewMessageId()
            send(('readFile_c2n', self, filename, blockNumber, nbytes, messageId), to=namenodes)
            await(some(received(('readFile_n2c', _filename, _blockNumber, _messageId, _))))

            """
        output('client: received list of datanodes for filename={0}, blockNumber={1}: {2}'.format(filename, blockNumber,r))
            # Client contacts one of datanode for data
            # TODO - handle case when r in None
        datanodeToContact = r[0][0]
        filenameAtDatanode = r[0][1]
        messageId = getNewMessageId()
        send(('readFile_c2d', self, filenameAtDatanode, nbytes, messageId), to=datanodeToContact)

        await(some(received(('readFile_d2c', _filenameAtDatanode, _nbytes, _messageId, _))))
        result = setof(r, received(('readFile_d2c', _filenameAtDatanode, _nbytes, _messageId, r) ))
        read_data = Utils.getOneFromSet(result)
        output('client: received data from datanode for filename={0}, blockNumber={1}: {2}'.format(filename, blockNumber,
                                                                                                  read_data))
        send(('readFile', token, filename, blockNumber, nbytes, read_data), to=user)
            """
            result = setof(r, received(('readFile_n2c', _filename, _blockNumber, _messageId, r)))
            # r is the list of (datanodes, location of block) which store the block client wants to read
            r = Utils.getOneFromSet(result)

            output('client: received list of datanodes for filename={0}, blockNumber={1}: {2}'.format(filename, blockNumber,
                                                                                                      r))
            # Client contacts one of datanode for data
            # TODO - handle case when r in None
            filenameAtDatanode, datanodesToContact = r
            if len(datanodesToContact) == 0:
                output('client: all datanodes hosting block={0} of file={1} are dead'.format(blockNumber, filename))
                data = (False, b'')
                send(('readFile', token, filename, mblockNumber, nbytes, data), to=user)
                return
            datanodeToContact = datanodesToContact[0]
            messageId = getNewMessageId()
            send(('readFile_c2d', self, filenameAtDatanode, nbytes, messageId), to=datanodeToContact)

            await(some(received(('readFile_d2c', _filenameAtDatanode, _nbytes, _messageId, _))))
            result = setof(r, received(('readFile_d2c', _filenameAtDatanode, _nbytes, _messageId, r) ))
            read_data = Utils.getOneFromSet(result)
            data += read_data
            bytes_read += len(read_data)
            blockNumber += 1
            output('client: received data from datanode for filename={0}, blockNumber={1}: {2}'.format(filename, blockNumber,
                                                                                                      read_data))
        data = data[:nbytes]
        output("client: read all data: ", data)
        return_data = (True, data)
        output("client: sending= ", ('readFile', token, filename, mblockNumber, nbytes, return_data))
        send(('readFile', token, filename, mblockNumber, nbytes, return_data), to=user)

    """
	When a client writes, it  first  asks  the  NameNode  to  choose  DataNodes  to  host  
        replicas of the first block of the file. The client organizes a pipeline 
        from  node -to-node  and  sends  the  data.  When  the  first  block  is 
        filled,  the  client  requests  new DataNodes  to  be  chosen  to  host 
        replicas of the next block.
    """
    def receive(msg=('appendFile', token, filename, data), from_=user):
        output('client: received appendFile: filename={0}, token={1}, data={2}'.format(filename, token, data))
        dataWriteIndex = 0
        while dataWriteIndex < len(data):
            messageId = getNewMessageId()
            send(('appendFile_c2n', self, filename, messageId), to=namenodes)
            await(some(received(('appendFile_n2c', _filename, _messageId, _,))))
            result = setof(r, received(('appendFile_n2c', _filename, _messageId, r)))
            datanodes_to_write, blockName, blockSize, blockNumber = Utils.getOneFromSet(result)
            output("client: received nominated datanodes for filename={0}: {1}, blockName={2}, nbytes={3}".format(filename, datanodes_to_write, blockName, blockSize))

            # If namenode nominates no datanode, send False to user
            if len(datanodes_to_write) == 0:
                output('client: namenode nominated no datanode to append to file: ', filename)
                send(('appendFile', token, filename, False), to=user)
                return

            messageIdList = []
            messageIdDict = dict()
            for d in datanodes_to_write:
                messageIdList.append(getNewMessageId())
                messageIdDict[d] = messageIdList[-1]
            # TODO - do setup/handshake with all datanodes before writing!!!
            messageIdTuple = tuple(messageIdList)
            dataWriteEndIndex = min(dataWriteIndex + blockSize, len(data))
            dataPacket = data[dataWriteIndex:dataWriteEndIndex]
            dataWriteIndex = dataWriteEndIndex
            send(('appendFile_c2d', filename, blockName, blockNumber, dataPacket, datanodes_to_write, messageIdTuple, 0, self), to=datanodes_to_write[0])
            # TODO - await for all datanodes to finish. Then notify user
            for d in datanodes_to_write:
                await( received(('appendFile_d2c', messageIdDict[d])))
            #await(each d in datanodes_to_write, has= received(('appendFile_d2c', messageIdDict[d])))
            output("client: append packet={0} complete".format(dataPacket))
        output('appendFile complete!!')
        send(('appendFile', token, filename, True), to=user)


    """
	Handles requests to delete a file, Returns true if successful and false if some other user is editing the file
    """
    def receive(msg=('deleteFile', token, filename), from_=user):
        output('client: received deleteFile: filename={0}'.format(filename))
        messageId = getNewMessageId()
        send(('deleteFile', self, filename, messageId), to=namenodes)
        await(some(received(('deleteFile', _filename, _messageId, _))))
        result = setof(r, received(('deleteFile', _filename, _messageId, r)))
        r = Utils.getOneFromSet(result)
        output("client: received result of deleteFile from namenode for file: ",filename, 'result= ',r)
        send(('deleteFile', token, filename), to=user)
