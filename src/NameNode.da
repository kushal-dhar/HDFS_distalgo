'''
from DataNode import DataNode
'''
import threading, time
from FileAttributes import Inode, Lease
from Block import BlockInfo
import Config
import random


"""
LeaseMonitor process to monitor Lease Timeout
"""
class LeaseMonitor(process):
    def setup(namenode):
        self.hard_limit = Config.CLIENT_HARD_LIMIT   #300 seconds for hard_limit of each lease
        self.namenode = namenode

    def run():
        output("Lease Monitor process started")
        send(('getLeaseInfo', self), to=namenode)
        await(received(('kill')))


    def receive(msg=('leaseInfo', clientTimeStamp, file2leaseobj)):
        output("Received leaseinfo from NameNode")
        currentTime = time.time()
        for eachFile in file2leaseobj:
            output("lease: ",file2leaseobj[eachFile], clientTimeStamp)
            #leaseObj = file2leaseobj[eachFile]
            if currentTime - clientTimeStamp[file2leaseobj[eachFile].client] >= hard_limit:
                output("file2leaseobj: ",file2leaseobj)
                send(('closeFile', Config.W_LEASE, None, file2leaseobj[eachFile].filename, -1), to=namenode)
        time.sleep(60)
        send(('getLeaseInfo', self), to=namenode)



"""
Namenode process in HDFS cluster
"""
class NameNode(process):
#class NameNode():
    """
    def __init__():
        datanodes = None
        # dict: filename -> Inode
        inodes = None
        # dict: filename -> BlockInfo
        blockinfo = None
        pass
    """
    def setup():
        self.datanodeId2pid = dict()
        self.pid2datanodeId = dict()
        self.nextDatanodeId = 1
        self.file2leasereq = dict()
        self.file2leaseobj = dict()
        # dict: filename -> Inode
        self.inodes = dict()
        self.clientTimeStamp = dict()

        # dict: filename -> BlockInfo
        self.blockinfo = dict()

        self.mapLock = threading.Lock()
        self.counterLock = threading.Lock()
        self.locks = [self.mapLock, self.counterLock]


    def run():
        output('namenode running: ', self)
        monitorProcess = new(LeaseMonitor, num=1, at=Config.NAMENODE_LOCATION)
        for mp in monitorProcess:
            setup(mp, args=(self,))
        start(monitorProcess)
        await(received(('kill')))


    def nominateDataNodes(filename, count=3):
        """
        Nominates `count` datanodes for storing a new block of a file
        """
        pass


    def getDatanodesOfBlock(filename, blockNumber):
        """
        Returns the datanodes at which the block `blockNumber` of `filename` is located
        """
        pass


    def getImage():
        """
        Returns the current image of namesystem.
        It containes blockinfo and inode data.
        """
        pass


    def connectDatanode(datanode):
        """
        Performs handshake and verification of datanode.
        After this passes, datanode is available for storing data blocks.
        """
        pass


    def handleBlockReport(datanode, report):
        """
        Analyses the block report sent by datanode.
        Done asynchronously.
        """
        pass


    def handleDatanodeHeartbeat(datanode, heatbeat):
        """
        Analyse the heartbeat message sent by datanode.
        Replies to the heartbeat and sends further instructions.
        """
        pass


    def handleDatanodeDown(datanode):
        """
        Takes the necessary steps when a datanode is presumed to be down.
        Schedules replciation of the blocks which the datanode was storing.
        """
        pass


    def analyseSystemHealth():
        """
        Perform analysis of overall health of the system.
        - schedule replication of under replicated blocks
        - schedule deletion of over replicated blocks
        - take action when storage on datanode is running out
        - do garbage collection
        """
        pass


    def grantLease(client, req_info):
        """
        Grants lease of `filename` to the client.
        """
        if(req_info[0] not in self.file2leaseobj):
             leaseObj = Lease(client, req_info[0],req_info[1])
             if req_info[1] == Config.R_LEASE:
                 leaseObj.readers += 1
             self.file2leaseobj[req_info[0]] =  leaseObj
        else:
            leaseObj = self.file2leaseobj[req_info[0]]
            # If mode is READERS, increase READERS count otherwise make leaseType as WRITE_LEASE
            # so that during deletion, we don't delete incase someone is reading or writing
            if req_info[1] == Config.R_LEASE:
                leaseObj.readers += 1
            else:
                leaseObj.leaseType = req_info[1]
            self.file2leaseobj[req_info[0]] = leaseObj
        output("Lease acquired for file: %s by client: %s" %(req_info[0], client))
        send(('openFile', req_info[0], req_info[1], req_info[2], True), to=client)


    def handleCorruptedBlock(filename, blockNumber):
        """
        Performs the necessary actions when it is notified that a block has been corrupted
        """
        pass


    def receive(msg=('hello')):
        output('handler: received hello from someone')


    def receive(msg=('add_datanode', datanode, proposedId)):
        output('received add_datanode: ', datanode)
        if proposedId is None:
            acquireLock(counterLock)
            pid2datanodeId[datanode] = self.nextDatanodeId
            datanodeId2pid[self.nextDatanodeId] = datanode
            self.nextDatanodeId += 1
            releaseLock(counterLock)
        else:
            oldPid = datanodeId2pid[proposedId]
            acquireLock(mapLock)
            del pid2datanodeId[oldPid]
            pid2datanodeId[datanode] = proposedId
            datanodeId2pid[proposedId] = datanode
            releaseLock(mapLock)
        send(('datanode_added', pid2datanodeId[datanode]), to=set([datanode]))
        output('added datanode: ', datanode, ' -> ', pid2datanodeId[datanode])


    def receive(msg=('heartbeat', datanode)):
        output('received heartbeat from datanode: ', datanode)


    def receive(msg=('heartbeat_client',clientnode)):
        output('received hearbeat from clientnode: ', clientnode)
        clientTimeStamp[clientnode] = time.time()
        output("clientnode timestamp: ",clientTimeStamp[clientnode])


    def receive(msg=('createFile', client, filename, messageId)):
        output('received create file ', filename, ' request from ', client)
        if filename in self.inodes:
            send(('createFile', filename, messageId, False), to=client)
            return
        self.inodes[filename] = Inode(filename)
        self.blockinfo[filename] = BlockInfo(filename, self.inodes[filename])
        #output('sending to client: ', ('createFile', filename, messageId, True))
        send(('createFile', filename, messageId, True), to=client)


    def receive(msg=('listFiles', client, messageId)):
        output('received listFiles request from : ', client)
        files = [filename for filename in inodes]
        filesStr = ','.join(files)
        output('list of files: ', filesStr)
        send(('listFiles', messageId, filesStr), to=client)


    def receive(msg=('openFile', mode, client, filename, messageId)):
        output('received openFile request from : ', client)
        if filename not in self.inodes:
            output('file ', filename, ' not present')
            result = False
        else:
            req_info = (filename, mode, messageId, client)
            if(mode  == Config.R_LEASE):
                grantLease(client, req_info)
            else:
                if(filename in self.file2leasereq and len(file2leasereq[filename]) > 0):
                   self.file2leasereq[filename].append(req_info)
                   return
                else:
                    self.file2leasereq[filename] = []
                    self.file2leasereq[filename].append(req_info)
                    grantLease(client, req_info)
            # acquire lease for the file
            output('acquired lease for filename: ', filename)
            result = True
        output("args in openfile: ",filename, mode, messageId, result, client)
        send(('openFile', filename, mode, messageId, result), to=client)
        output("Message sent from Namenode to client")


    def receive(msg=('readFile_c2n', client, filename, blockNumber, nbytes, messageId)):
        output('received readFile request from {0}: filename={1}, blockNumber={2}, nbytes={3}'.format(client, filename, blockNumber, nbytes))

        # TODO: change it to find only datanodes which host the data
        datanodes_hosting_ids = self.blockinfo[filename].getDatanodeIdsForBlock(blockNumber)
        datanodes_hosting_Pids = tuple([self.datanodeId2pid[d] for d in datanodes_hosting_ids])
        filepath = filename + '.block.' + str(blockNumber)
        #result_datanodes = tuple([datanodes_hosting_Pids for item in self.pid2datanodeId.keys()])
        result = (filepath, datanodes_hosting_Pids)
        output('namenode: result of readfile: ', result)
        send(('readFile_n2c', filename, blockNumber, messageId, result), to=client)


    def receive(msg=('closeFile', mode, client, filename, messageId)):
        output('received closeFile request from : ', client)
        output('releasing lease for file: ',filename)
        if (mode == Config.R_LEASE):
            # Decrease the number of readers count for this file
            leaseObj = file2leaseobj[filename]
            leaseObj.readers -= 1
            file2leaseobj[filename] = leaseObj
            send(('closeFile', filename, mode, messageId, True), to=client)
        else:
            self.file2leasereq[filename].pop(0)
            if len(file2leasereq[filename]) > 0:
                req_info =  self.file2leasereq[filename][0]
                output("closeFile args: ",filename, mode, messageId)
                send(('closeFile', filename, mode, messageId, True), to=client)
                grantLease(req_info[3],req_info)
                output("Closed File: ",filename)
            else:
                leaseObj = file2leaseobj[filename]
                leaseObj.leaseType = None
                self.file2leaseobj[filename] = leaseObj
                output("closeFile args: ", filename, mode, messageId)
                send(('closeFile', filename, mode, messageId, True), to=client)
                output("Closed File: ",filename)
            """
            TO-DO : Add the timestamp for latest lease
            """

    def receive(msg=('deleteFile', client, filename, messageId)):
        output('received deleteFile request from: %s for file: %s' %(client, filename))
        leaseObj = file2leaseobj[filename]
        # If there are no reader and writer process working on this file, then delete this file
        output("leaseObj: ",leaseObj.leaseType, leaseObj.readers)
        if leaseObj.leaseType == None and leaseObj.readers == 0:
            output("deleteFile: Going to delete file: ",filename)
            numBlocks = blockinfo[filename].getNumberOfBlocks()
            for block in range(numBlocks):
                dataNodes = blockinfo[filename].getDatanodeIdsForBlock(block)
                blockname = filename + '.block.' + str(block)
                for node in dataNodes:
                    dataNodePID = datanodeId2pid[node]
                    send(('deleteBlock', blockname), to=dataNodePID)
            del blockinfo[filename]
            del inodes[filename]

            send(('deleteFile', filename, messageId, True), to=client)
        else:
            send(('deleteFile', filename, messageId, False), to=client)


    def receive(msg=('getLeaseInfo', leaseMonitor)):
        output('received getLeaseInfo from LeaseMonitor')
        send(('leaseInfo', clientTimeStamp, file2leaseobj), to=leaseMonitor)


    def receive(msg=('appendFile_c2n', client, filename, messageId)):
        output('received appendFile request from {0}: filename={1}, messageId={2}'.format(client, filename, messageId))

        blockNumber, bytesToWrite, newDatanodeToWrite = self.blockinfo[filename].getNewAppendInfo()

        # Create fresh block and store data
        if newDatanodeToWrite:
            #output("namenode: allocating new block for append to filename={0}".format(filename))
            datanodes = [d for d in self.pid2datanodeId.keys()]
            # If alive datanodes are less than replication factor, nominate all datanodes for storing blocks
            if len(datanodes) > Config.BLOCK_REPLICATION_FACTOR:
                selectedDatanodes = tuple(random.sample(datanodes, Config.BLOCK_REPLICATION_FACTOR))
            else:
                selectedDatanodes = tuple(datanodes)
            #bytesToWrite = Config.BLOCK_SIZE
            #blockNumber = self.blockinfo[filename].getLastBlockNumber() + 1
        # Append to the last written block
        else:
            #bytesToWrite = Config.BLOCK_SIZE - lastBlockSize
            #output("namenode: appending to last block for append to filename={0}".format(filename))
            selectedDatanodeIds = self.blockinfo[filename].getLastBlockDatanodeIds()
            # Get PID from datanode Id
            # TODO - handle datanode failure
            selectedDatanodes = tuple([self.datanodeId2pid[d] for d in selectedDatanodeIds])
            #blockNumber = self.blockinfo[filename].getLastBlockNumber()

        blockName = filename + '.block.' + str(blockNumber)
        replyData = (selectedDatanodes, blockName, bytesToWrite, blockNumber)
        send(('appendFile_n2c', filename, messageId, replyData), to=client)

    def receive(msg=('appendFile_d2n', filename, blockNumber, bytesWritten, datanodeId)):
        #output("namenode: received appendFile confirmation for filename={0} from datanode={1}".format(filename, datanodeId))
        # update this append information in blockinfo
        self.blockinfo[filename].addAppendInfo(blockNumber, bytesWritten, datanodeId)
        #output("namenode: after append info={0}".format(str(self.blockinfo[filename])))


    def receive(msg=('numBlocksInFile', filename, messageId), from_= client):
        nBlocks = self.blockinfo[filename].getNumberOfBlocks()
        send(('numBlocksInFile', filename, messageId, nBlocks), to=client)


    def acquireLock(lockObj):
        for obj in locks:
            if obj != lockObj:
                obj.acquire()
            else:
                obj.acquire()
                break
        return


    def releaseLock(lockObj):
        lockFound = False
        for obj in reversed(locks):
            if obj != lockObj and not lockFound:
                continue
            if obj == lockObj:
                obj.release()
                lockFound = True
            elif lockFound:
                obj.release()
        return

