'''
from Block import BlockInfo
from DataNode import DataNode
'''
import threading
from FileAttributes import Inode


"""
Namenode process in HDFS cluster
"""
class NameNode(process):
#class NameNode():
    """
    def __init__():
        datanodes = None
        # dict: filename -> Inode
        inodes = None
        # dict: filename -> BlockInfo
        blockinfo = None
        pass
    """
    def setup():
        self.datanodeId2pid = dict()
        self.pid2datanodeId = dict()
        self.nextDatanodeId = 1
        # dict: filename -> Inode
        self.inodes = dict()
        self.mapLock = threading.Lock()
        self.counterLock = threading.Lock()
        self.locks = [self.mapLock, self.counterLock]


    def run():
        output('namenode running: ', self)
        await(received(('kill')))
    
    def nominateDataNodes(filename, count=3):
        """
        Nominates `count` datanodes for storing a new block of a file
        """
        pass
    
    def getDatanodesOfBlock(filename, blockNumber):
        """
        Returns the datanodes at which the block `blockNumber` of `filename` is located
        """
        pass
    
    def getImage():
        """
        Returns the current image of namesystem.
        It containes blockinfo and inode data.
        """
        pass
    
    def connectDatanode(datanode):
        """
        Performs handshake and verification of datanode.
        After this passes, datanode is available for storing data blocks.
        """
        pass
    
    def handleBlockReport(datanode, report):
        """
        Analyses the block report sent by datanode.
        Done asynchronously.
        """
        pass
    
    def handleDatanodeHeartbeat(datanode, heatbeat):
        """
        Analyse the heartbeat message sent by datanode.
        Replies to the heartbeat and sends further instructions.
        """
        pass
        
    def handleDatanodeDown(datanode):
        """
        Takes the necessary steps when a datanode is presumed to be down.
        Schedules replciation of the blocks which the datanode was storing.
        """
        pass
    
    def analyseSystemHealth():
        """
        Perform analysis of overall health of the system.
        - schedule replication of under replicated blocks
        - schedule deletion of over replicated blocks
        - take action when storage on datanode is running out
        - do garbage collection
        """
        pass
        
    def grantLease(client, filename):
        """
        Grants lease of `filename` to the client.
        """
        pass
        
    def handleCorruptedBlock(filename, blockNumber):
        """
        Performs the necessary actions when it is notified that a block has been corrupted
        """
        pass

    def receive(msg=('hello')):
        output('handler: received hello from someone')

    def receive(msg=('add_datanode', datanode, proposedId)):
        output('received add_datanode: ', datanode)
        if proposedId is None:
            acquireLock(counterLock)
            pid2datanodeId[datanode] = self.nextDatanodeId
            datanodeId2pid[self.nextDatanodeId] = datanode
            self.nextDatanodeId += 1
            releaseLock(counterLock)
        else:
            oldPid = datanodeId2pid[proposedId]
            acquireLock(mapLock)
            del pid2datanodeId[oldPid]
            pid2datanodeId[datanode] = proposedId
            datanodeId2pid[proposedId] = datanode
            releaseLock(mapLock)

        send(('datanode_added', pid2datanodeId[datanode]), to=set([datanode]))
        output('added datanode: ', datanode, ' -> ', pid2datanodeId[datanode])

    def receive(msg=('heartbeat', datanode)):
        output('received heartbeat from datanode: ', datanode)


    def receive(msg=('createFile', client, filename, messageId)):
        output('received create file ', filename, ' request from ', client)
        if filename in self.inodes:
            send(('createFile', filename, messageId, False), to=client)
            return
        self.inodes[filename] = Inode(filename)
        #output('sending to client: ', ('createFile', filename, messageId, True))
        send(('createFile', filename, messageId, True), to=client)


    def receive(msg=('listFiles', client, messageId)):
        output('received listFiles request from : ', client)
        files = [filename for filename in inodes]
        filesStr = ','.join(files)
        output('list of files: ', filesStr)
        send(('listFiles', messageId, filesStr), to=client)

    def receive(msg=('openFile', mode, client, filename, messageId)):
        output('received openFile request from : ', client)
        if filename not in self.inodes:
            output('file ', filename, ' not present')
            result = False
        else:
            # acquire lease for the file
            output('acquired lease for filename: ', filename)
            result = True
        send(('openFile', filename, mode, messageId, result), to=client)


    def acquireLock(lockObj):
        for obj in locks:
            if obj != lockObj:
                obj.acquire()
            else:
                obj.acquire()
                break
        return

    def releaseLock(lockObj):
        lockFound = False
        for obj in reversed(locks):
            if obj != lockObj and not lockFound:
                continue
            if obj == lockObj:
                obj.release()
                lockFound = True
            elif lockFound:
                obj.release()
        return

