'''
from DataNode import DataNode
'''
import threading
from FileAttributes import Inode
from Block import BlockInfo
import Config
import random

"""
Namenode process in HDFS cluster
"""
class NameNode(process):
#class NameNode():
    """
    def __init__():
        datanodes = None
        # dict: filename -> Inode
        inodes = None
        # dict: filename -> BlockInfo
        blockinfo = None
        pass
    """
    def setup():
        self.datanodeId2pid = dict()
        self.pid2datanodeId = dict()
        self.nextDatanodeId = 1
        # dict: filename -> Inode
        self.inodes = dict()

        # dict: filename -> BlockInfo
        self.blockinfo = dict()

        self.mapLock = threading.Lock()
        self.counterLock = threading.Lock()
        self.locks = [self.mapLock, self.counterLock]


    def run():
        output('namenode running: ', self)
        await(received(('kill')))
    
    def nominateDataNodes(filename, count=3):
        """
        Nominates `count` datanodes for storing a new block of a file
        """
        pass
    
    def getDatanodesOfBlock(filename, blockNumber):
        """
        Returns the datanodes at which the block `blockNumber` of `filename` is located
        """
        pass
    
    def getImage():
        """
        Returns the current image of namesystem.
        It containes blockinfo and inode data.
        """
        pass
    
    def connectDatanode(datanode):
        """
        Performs handshake and verification of datanode.
        After this passes, datanode is available for storing data blocks.
        """
        pass
    
    def handleBlockReport(datanode, report):
        """
        Analyses the block report sent by datanode.
        Done asynchronously.
        """
        pass
    
    def handleDatanodeHeartbeat(datanode, heatbeat):
        """
        Analyse the heartbeat message sent by datanode.
        Replies to the heartbeat and sends further instructions.
        """
        pass
        
    def handleDatanodeDown(datanode):
        """
        Takes the necessary steps when a datanode is presumed to be down.
        Schedules replciation of the blocks which the datanode was storing.
        """
        pass
    
    def analyseSystemHealth():
        """
        Perform analysis of overall health of the system.
        - schedule replication of under replicated blocks
        - schedule deletion of over replicated blocks
        - take action when storage on datanode is running out
        - do garbage collection
        """
        pass
        
    def grantLease(client, filename):
        """
        Grants lease of `filename` to the client.
        """
        pass
        
    def handleCorruptedBlock(filename, blockNumber):
        """
        Performs the necessary actions when it is notified that a block has been corrupted
        """
        pass

    def receive(msg=('hello')):
        output('handler: received hello from someone')

    def receive(msg=('add_datanode', datanode, proposedId)):
        output('received add_datanode: ', datanode)
        if proposedId is None:
            acquireLock(counterLock)
            pid2datanodeId[datanode] = self.nextDatanodeId
            datanodeId2pid[self.nextDatanodeId] = datanode
            self.nextDatanodeId += 1
            releaseLock(counterLock)
        else:
            oldPid = datanodeId2pid[proposedId]
            acquireLock(mapLock)
            del pid2datanodeId[oldPid]
            pid2datanodeId[datanode] = proposedId
            datanodeId2pid[proposedId] = datanode
            releaseLock(mapLock)

        send(('datanode_added', pid2datanodeId[datanode]), to=set([datanode]))
        output('added datanode: ', datanode, ' -> ', pid2datanodeId[datanode])

    def receive(msg=('heartbeat', datanode)):
        output('received heartbeat from datanode: ', datanode)


    def receive(msg=('createFile', client, filename, messageId)):
        output('received create file ', filename, ' request from ', client)
        if filename in self.inodes:
            send(('createFile', filename, messageId, False), to=client)
            return
        self.inodes[filename] = Inode(filename)
        self.blockinfo[filename] = BlockInfo(filename, self.inodes[filename])
        #output('sending to client: ', ('createFile', filename, messageId, True))
        send(('createFile', filename, messageId, True), to=client)


    def receive(msg=('listFiles', client, messageId)):
        output('received listFiles request from : ', client)
        files = tuple([filename for filename in inodes])
        output('list of files: ', files)
        send(('listFiles', messageId, files), to=client)

    def receive(msg=('openFile', mode, client, filename, messageId)):
        output('received openFile request from : ', client)
        if filename not in self.inodes:
            output('file ', filename, ' not present')
            result = False
        else:
            # acquire lease for the file
            output('acquired lease for filename: ', filename)
            result = True
        send(('openFile', filename, mode, messageId, result), to=client)



    def receive(msg=('readFile_c2n', client, filename, blockNumber, nbytes, messageId)):
        output('received readFile request from {0}: filename={1}, blockNumber={2}, nbytes={3}'.format(client, filename, blockNumber, nbytes))

        # TODO: change it to find only datanodes which host the data
        datanodes_hosting_ids = self.blockinfo[filename].getDatanodeIdsForBlock(blockNumber)
        datanodes_hosting_Pids = tuple([self.datanodeId2pid[d] for d in datanodes_hosting_ids])
        filepath = filename + '.block.' + str(blockNumber)
        #result_datanodes = tuple([datanodes_hosting_Pids for item in self.pid2datanodeId.keys()])
        result = (filepath, datanodes_hosting_Pids)
        output('namenode: result of readfile: ', result)
        send(('readFile_n2c', filename, blockNumber, messageId, result), to=client)

    def receive(msg=('appendFile_c2n', client, filename, messageId)):
        output('received appendFile request from {0}: filename={1}, messageId={2}'.format(client, filename, messageId))

        blockNumber, bytesToWrite, newDatanodeToWrite = self.blockinfo[filename].getNewAppendInfo()

        # Create fresh block and store data
        if newDatanodeToWrite:
            output("namenode: allocating new block for append to filename={0}".format(filename))
            datanodes = [d for d in self.pid2datanodeId.keys()]
            # If alive datanodes are less than replication factor, nominate all datanodes for storing blocks
            if len(datanodes) > Config.BLOCK_REPLICATION_FACTOR:
                selectedDatanodes = tuple(random.sample(datanodes, Config.BLOCK_REPLICATION_FACTOR))
            else:
                selectedDatanodes = tuple(datanodes)
            #bytesToWrite = Config.BLOCK_SIZE
            #blockNumber = self.blockinfo[filename].getLastBlockNumber() + 1
        # Append to the last written block
        else:
            #bytesToWrite = Config.BLOCK_SIZE - lastBlockSize
            output("namenode: appending to last block for append to filename={0}".format(filename))
            selectedDatanodeIds = self.blockinfo[filename].getLastBlockDatanodeIds()
            # Get PID from datanode Id
            # TODO - handle datanode failure
            selectedDatanodes = tuple([self.datanodeId2pid[d] for d in selectedDatanodeIds])
            #blockNumber = self.blockinfo[filename].getLastBlockNumber()

        blockName = filename + '.block.' + str(blockNumber)
        replyData = (selectedDatanodes, blockName, bytesToWrite, blockNumber)
        send(('appendFile_n2c', filename, messageId, replyData), to=client)

    def receive(msg=('appendFile_d2n', filename, blockNumber, bytesWritten, datanodeId)):
        output("namenode: received appendFile confirmation for filename={0} from datanode={1}".format(filename, datanodeId))
        # update this append information in blockinfo
        self.blockinfo[filename].addAppendInfo(blockNumber, bytesWritten, datanodeId)
        output("namenode: after append info={0}".format(str(self.blockinfo[filename])))




    def acquireLock(lockObj):
        for obj in locks:
            if obj != lockObj:
                obj.acquire()
            else:
                obj.acquire()
                break
        return

    def releaseLock(lockObj):
        lockFound = False
        for obj in reversed(locks):
            if obj != lockObj and not lockFound:
                continue
            if obj == lockObj:
                obj.release()
                lockFound = True
            elif lockFound:
                obj.release()
        return

