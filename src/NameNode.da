'''
from DataNode import DataNode
'''
import threading, time
from FileAttributes import Inode, Lease
from Block import BlockInfo
import Config


"""
LeaseMonitor process to monitor Lease Timeout
"""
class LeaseMonitor(process):
    def setup(namenode):
        self.hard_limit = Config.CLIENT_HARD_LIMIT   #300 seconds for hard_limit of each lease
        self.namenode = namenode

    def run():
        output("Lease Monitor process started")
        send(('getLeaseInfo', self), to=namenode)
        await(received(('kill')))


    def receive(msg=('leaseInfo', clientTimeStamp, file2leaseobj)):
        output("Received leaseinfo from NameNode")
        currentTime = time.time()
        for eachFile in file2leaseobj:
            if currentTime - clientTimeStamp[eachFile.client] >= hard_limit:
                send(('closeFile', Config.W_LEASE, eachFile.client, eachFile.filename, -1), to=namenode)
        time.sleep(60)
        send(('getLeaseInfo', self), to=namenode)



"""
Namenode process in HDFS cluster
"""
class NameNode(process):
#class NameNode():
    """
    def __init__():
        datanodes = None
        # dict: filename -> Inode
        inodes = None
        # dict: filename -> BlockInfo
        blockinfo = None
        pass
    """
    def setup():
        self.datanodeId2pid = dict()
        self.pid2datanodeId = dict()
        self.nextDatanodeId = 1
        self.file2leasereq = dict()
        self.file2leaseobj = dict()
        # dict: filename -> Inode
        self.inodes = dict()
        self.clientTimeStamp = dict()

        # dict: filename -> BlockInfo
        self.blockinfo = dict()

        self.mapLock = threading.Lock()
        self.counterLock = threading.Lock()
        self.locks = [self.mapLock, self.counterLock]


    def run():
        output('namenode running: ', self)
        monitorProcess = new(LeaseMonitor, num=1, at=Config.NAMENODE_LOCATION)
        for mp in monitorProcess:
            setup(mp, args=(self,))
        start(monitorProcess)
        await(received(('kill')))


    def nominateDataNodes(filename, count=3):
        """
        Nominates `count` datanodes for storing a new block of a file
        """
        pass


    def getDatanodesOfBlock(filename, blockNumber):
        """
        Returns the datanodes at which the block `blockNumber` of `filename` is located
        """
        pass


    def getImage():
        """
        Returns the current image of namesystem.
        It containes blockinfo and inode data.
        """
        pass


    def connectDatanode(datanode):
        """
        Performs handshake and verification of datanode.
        After this passes, datanode is available for storing data blocks.
        """
        pass


    def handleBlockReport(datanode, report):
        """
        Analyses the block report sent by datanode.
        Done asynchronously.
        """
        pass


    def handleDatanodeHeartbeat(datanode, heatbeat):
        """
        Analyse the heartbeat message sent by datanode.
        Replies to the heartbeat and sends further instructions.
        """
        pass


    def handleDatanodeDown(datanode):
        """
        Takes the necessary steps when a datanode is presumed to be down.
        Schedules replciation of the blocks which the datanode was storing.
        """
        pass


    def analyseSystemHealth():
        """
        Perform analysis of overall health of the system.
        - schedule replication of under replicated blocks
        - schedule deletion of over replicated blocks
        - take action when storage on datanode is running out
        - do garbage collection
        """
        pass


    def grantLease(client, req_info):
        """
        Grants lease of `filename` to the client.
        """

        if(req_info[0] not in self.file2leaseobj):
             leaseObj = Lease(client, req_info[0],req_info[1])
             self.file2leaseobj[req_info[0]] =  leaseObj
        else:
            leaseObj = self.file2leaseobj[req_info[0]]
            leaseObj.leaseType = req_info[1]
        output("Lease acquired")
        send(('openFile', req_info[0], req_info[1], req_info[2], True), to=client)


    def handleCorruptedBlock(filename, blockNumber):
        """
        Performs the necessary actions when it is notified that a block has been corrupted
        """
        pass


    def receive(msg=('hello')):
        output('handler: received hello from someone')


    def receive(msg=('add_datanode', datanode, proposedId)):
        output('received add_datanode: ', datanode)
        if proposedId is None:
            acquireLock(counterLock)
            pid2datanodeId[datanode] = self.nextDatanodeId
            datanodeId2pid[self.nextDatanodeId] = datanode
            self.nextDatanodeId += 1
            releaseLock(counterLock)
        else:
            oldPid = datanodeId2pid[proposedId]
            acquireLock(mapLock)
            del pid2datanodeId[oldPid]
            pid2datanodeId[datanode] = proposedId
            datanodeId2pid[proposedId] = datanode
            releaseLock(mapLock)

        send(('datanode_added', pid2datanodeId[datanode]), to=set([datanode]))
        output('added datanode: ', datanode, ' -> ', pid2datanodeId[datanode])


    def receive(msg=('heartbeat', datanode)):
        output('received heartbeat from datanode: ', datanode)


    def receive(msg=('heartbeat_client',clientnode)):
        output('received hearbeat from clientnode: ', clientnode)
        clientTimeStamp[clientnode] = time.time()
        output("clientnode timestamp: ",clientTimeStamp[clientnode])


    def receive(msg=('createFile', client, filename, messageId)):
        output('received create file ', filename, ' request from ', client)
        if filename in self.inodes:
            send(('createFile', filename, messageId, False), to=client)
            return
        self.inodes[filename] = Inode(filename)
        #output('sending to client: ', ('createFile', filename, messageId, True))
        send(('createFile', filename, messageId, True), to=client)


    def receive(msg=('listFiles', client, messageId)):
        output('received listFiles request from : ', client)
        files = [filename for filename in inodes]
        filesStr = ','.join(files)
        output('list of files: ', filesStr)
        send(('listFiles', messageId, filesStr), to=client)


    def receive(msg=('openFile', mode, client, filename, messageId)):
        output('received openFile request from : ', client)
        if filename not in self.inodes:
            output('file ', filename, ' not present')
            result = False
        else:
            req_info = (filename, mode, messageId)
            if(mode  == Config.R_LEASE):
                grantLease(client, req_info)
            else:
                if(filename in self.file2leasereq and len(file2leasereq[filename]) > 0):
                   self. file2leasereq[filename].append(req_info)
                   return
                else:
                    self.file2leasereq[filename] = []
                    self.file2leasereq[filename].append(req_info)
                    grantLease(client, req_info)
            # acquire lease for the file
            output('acquired lease for filename: ', filename)
            result = True
        send(('openFile', filename, mode, messageId, result), to=client)



    def receive(msg=('readFile_c2n', client, filename, blockNumber, nbytes, messageId)):
        output('received readFile request from {0}: filename={1}, blockNumber={2}, nbytes={3}'.format(client, filename, blockNumber, nbytes))

        # TODO: change it to find only datanodes which host the data
        result = tuple([(item, Config.TEST_FILE_PATH) for item in self.pid2datanodeId.keys()])
        output('namenode: result of readfile: ', result)
        send(('readFile_n2c', filename, blockNumber, messageId, result), to=client)


    def receive(msg=('closeFile', mode, client, filename, messageId)):
        output('received closeFile request from : ', client)
        if (mode == Config.R_LEASE):
            send(('closeFile', filename, mode, messageId, True), to=client)
        else:
            self.file2leasereq[filename].pop(0)
            req_info =  self.file2leasereq[filename][0]
            output("closeFile args: ",filename, mode, messageId)
            send(('closeFile', filename, mode, messageId, True), to=client)
            grantLease(client,req_info)
            output("Closed File")
            """
            TO-DO : Add the timestamp for latest lease

            """


    def receive(msg=('getLeaseInfo', leaseMonitor)):
        output('received getLeaseInfo from LeaseMonitor')
        send(('leaseInfo', clientTimeStamp, file2leaseobj), to=leaseMonitor)


    def acquireLock(lockObj):
        for obj in locks:
            if obj != lockObj:
                obj.acquire()
            else:
                obj.acquire()
                break
        return


    def releaseLock(lockObj):
        lockFound = False
        for obj in reversed(locks):
            if obj != lockObj and not lockFound:
                continue
            if obj == lockObj:
                obj.release()
                lockFound = True
            elif lockFound:
                obj.release()
        return

